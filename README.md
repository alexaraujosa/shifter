# Software Development - Course Shift Management System

## Description
The Course Shift Management System is a project developed for the **Software Development** course, primarily focusing on applying **Software Engineering** principles throughout the software development lifecycle. The system assists in creating practical shifts for university courses, considering student enrollments, schedules, and special status prioritization. Its development provides hands-on experience with various software engineering activities, such as modeling, design, and implementation.

### üéØ Purpose:
The main objective of this project is to practice and demonstrate **Software Engineering** concepts and methodologies, including:
- UML modeling (Domain Model, Use Cases, Class Diagrams)
- Multi-layer architecture design
- Object-oriented programming (Java)
- Version control with GitHub
- Conflict detection in scheduling
- Systematic development approach from requirements gathering to design, implementation, and testing

### üöÄ Key Features:
- **Shift Allocation**: Automatically assigns students to shifts based on enrollment data and course requirements, serving as a practical application of software development techniques.
- **Conflict Detection**: Ensures no schedule overlaps for students across different course units (UCs), showcasing the handling of complex logic and conditions in software.
- **Priority Handling**: Implements prioritization algorithms for students with special statuses (e.g., working students, athletes), demonstrating how to incorporate real-world constraints into a system.
- **Flexible Policies**: Supports custom UC-specific rules (e.g., mandatory same-shift group members), offering insights into how software can handle dynamic requirements.
- **Multi-Layer Architecture**: Follows a decoupled architecture (presentation, business, and data layers) for scalability and maintainability, emphasizing software design best practices.
- **GitHub Integration**: Ensures efficient version control, issue tracking, and team collaboration, mimicking a real-world development environment.
- **Reporting**: Provides shift lists, conflict reports, and prioritization summaries, demonstrating how to present complex data to users.

## üìö Learning Outcomes
Through this project, we have:
- **UML Modeling**: Created domain models, use case diagrams, class diagrams, and sequence diagrams to formalize system requirements and visualize complex processes.
- **Java Development**: Implemented core functionality using object-oriented principles, highlighting design patterns and best practices in Java.
- **Team Collaboration**: Utilized GitHub for version control, issue tracking, and code reviews, developing collaborative workflow and continuous integration practices.
- **Software Design**: Applied software design principles and patterns to structure the system into manageable components, ensuring clear separation of concerns and maintainability.
- **Algorithm Design**: Designed and implemented various shift allocation strategies and prioritization algorithms, focusing on their efficiency and scalability.
- **Conflict Resolution**: Developed logic to detect and resolve scheduling conflicts, showcasing the importance of error handling and real-world problem-solving in system development.

## üöß Areas for Improvement
- **Requirements Gathering**: While we identified key features for the system, a more thorough and detailed requirements analysis could have helped in uncovering edge cases and further clarifying system constraints. This would ensure a more comprehensive understanding of user needs from the outset.
- **Use Case Refinement**: The initial use cases could be more granular. Some of the processes may benefit from splitting broad use cases into more specific ones, ensuring that all scenarios are captured accurately. This would improve the clarity of system interactions and better reflect real-world workflows.
- **Diagramming & Modeling**: While UML diagrams like domain models and class diagrams were created, they can be more detailed and refined. For example, a more in-depth class diagram could better represent relationships and dependencies, while sequence diagrams could be expanded to account for more detailed flows of interactions, particularly in complex use cases.

## üë®‚Äçüíª Contributors
- **Alex Ara√∫jo S√°** - [Alex S√°](https://github.com/alexaraujosa)
- **Paulo Alexandre Rodrigues Ferreira** - [Paulo](https://github.com/pauloarf)
- **Rafael Santos Fernandes** - [DarkenLM](https://github.com/DarkenLM)
- **Jorge Pereira** - [Alexandre Dias](https://github.com/KhalexO)
- **Alex Dias** - [Jorgeap64](https://github.com/Jorgeap64)

## üõ†Ô∏è Technologies Used
- **Programming Language**: Java
- **Modeling Tools**: Visual Paradigm for UML diagrams and modeling
- **Version Control**: GitHub
- **Architecture**: Multi-layer, promoting clean architecture principles
- **Documentation**: Markdown, PDF technical reports for documenting design decisions, system requirements, and testing procedures

## Final Grade

15/20
